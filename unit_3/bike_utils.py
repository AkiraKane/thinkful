__author__ = 'jriley''''Utility functions for Unit 3 Lesson 1 - How New Yorkers BikeI implemented the availability table differently than the example.I did something similar at work a few months ago.  I imported 75+ years ofeconomic indices from the US Federal Reserve data site.I inherited a one column per index, one row per timestamp design similar towhat this lesson implements. Very difficult to work with.I get why the lesson uses this design, but I'm not going there.Data is stored in two tables:  stations, which has the station's profile,and availability, which is an entry oftimestamp   station id  # bikesIf I expected to report on the bike traffic regularly, I would addanother column for the # difference and calculate the differencewhen I inserted a new result. That would mean querying the last entry (max timestamp)'''import requestsfrom pandas.io.json import json_normalizeimport sqlite3 as liteimport pandas as pdfrom dateutil.parser import parse as dateparsedb_name = 'citi_bike.db'def db_connect():    '''    Connect to our database.    # JR  Question - I know the 'with con.cursor()...' will clean up the cursor    at the end of the block.  Does this connection get cleaned up?    I have SQLite manager, but couldn't see whether it was accumulating open connections.    :return: a connection    '''    return lite.connect(db_name)def fetch_citibike_data():    df = json_normalize(fetch_citibike_json()['stationBeanList'])    return dfdef fetch_citibike_json():    r = requests.get('http://www.citibikenyc.com/stations/json')    return r.json()def create_tables(con):    with con:        con.cursor().execute('CREATE TABLE stations ' \                             '(id INT PRIMARY KEY, totalDocks INT, ' \                             'city TEXT, altitude INT, stAddress2 TEXT, ' \                             'longitude NUMERIC, postalCode TEXT, ' \                             'testStation TEXT, stAddress1 TEXT, ' \                             'stationName TEXT, landMark TEXT, ' \                             'latitude NUMERIC, location TEXT )')        con.cursor().execute('CREATE TABLE availability ' \                             '(id INT PRIMARY KEY, ' \                             'timestamp INT, ' \                             'station_id INT, ' \                             'bikes INT )') def init_station_data(data, con):    sql = 'INSERT INTO stations (id, totalDocks, city, altitude, stAddress2, ' \          'longitude, postalCode, testStation, stAddress1, stationName, ' \          'landMark, latitude, location) ' \          'VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)'    #populate values in the database    with con:        cur = con.cursor()        for station in data:            #id, totalDocks, city,            # altitude, stAddress2, longitude,            # postalCode, testStation, stAddress1,            # stationName, landMark, latitude, location)            #print station            #station_id = int(station['id'])            cur.execute(sql,(station['id'],station['totalDocks'],                             station['city'],                             station['altitude'],station['stAddress2'],                             float(station['longitude']),                             station['postalCode'],station['testStation'],                             station['stAddress1']                             ,station['stationName'],station['landMark'],                             float(station['latitude']),station['location']))def insert_data(timestamp, data, con):    '''    If I expected to report on the bike traffic regularly,    I would calculate the difference here and save it in a new column.    That would look something like:        * query the DB for the last set of data - something like        'SELECT availability.* FROM availability,         ( select max(timestamp) from availability) as last_reported         WHERE availability.timestamp = last_reported)         ORDER BY station_id'        * refactor add_bike_delta's signature to take this result set         and use it calculate changes        * add the change value to the insert statement    '''    sql = 'INSERT INTO availability (station_id, timestamp, bikes) ' \          'VALUES (?,?,?)'    #populate values in the database    with con:        cur = con.cursor()        for entry in data:            cur.execute(sql,(entry['id'], timestamp, entry['availableBikes']))def fetch_availability_data():    con = db_connect()    # JR a good coder would query the stations table for station name    # at report time instead of selecting it on every row.  Oh well.    query = 'SELECT a.station_id, a.bikes, a.timestamp, s.stationName ' \            'FROM availability a, stations s ' \            'WHERE a.station_id = s.id ' \            'ORDER BY a.station_id, a.timestamp ASC'    return pd.read_sql_query(query, con)def add_bike_delta(data):    '''    Calculate the change in number of bicycles since the last query    Add it in the 'change' column    :param data: a DataFrame, sorted in ascending order by station_id and timestamp    :return:    '''    # The data set is in sorted order    # As we iterate, remember the last row so we don't have to search in the data set    last = None    deltas = []    for index, item in data.iterrows():        if(last is  None or last['station_id'] != item['station_id']):            # first result for this station            deltas.append(0)        else:            deltas.append( item['bikes'] - last['bikes'])        last = item    data['change'] = map( lambda x: x, deltas)def init_db():    data = fetch_citibike_json()['stationBeanList']    con = db_connect()    create_tables(con)    init_station_data(data,con)def update_data():    con = db_connect()    data = fetch_citibike_json()    if data is not None:        timestamp = dateparse(data['executionTime'])        data = data['stationBeanList']        insert_data(timestamp, data, con)